<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600&display=swap" rel="stylesheet">
  <title>Salem Angels | Waitlist Map</title>

  <link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100vh; width: 100%; }
    .popup {
  font-family: 'Montserrat', sans-serif;
  font-size: 14px;
  line-height: 1.4;
  max-width: 320px;
  max-height: 260px;
  overflow: auto;
  white-space: normal;
  word-wrap: break-word;
  overflow-wrap: anywhere;

  background: #e1dbcb;         /* light background */
  border-radius: 8px;
  padding: 10px 12px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.15);
}
    .popup p {margin: 6px 0 0; }
    .popup h3 { 
      margin: 0 0 6px;
      font-size: 16px;
      font-weight: 600;
      color: #333;
    font-family: 'Montserrat', sans-serif;
  }
  </style>
</head>
<body>
  <div id="map"></div>

  <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
  <script>
  // Show any MapLibre/network errors in the console
  window.addEventListener('error', (e) => console.error('JS error:', e.error || e.message));
</script>

  <script>
  const MAPTILER_KEY = "o15caqslE6PxDORwZdRo";

  // === CONFIG: Google Sheet CSV URL ===
  const SHEET_CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vS5B8d-HEQNMYPh2Udg6W2jdN-Mjo4MYCF5In8ZyUrWK30P4fuRlSdh-SaiZrJDXEVgXXWud3ln2xOF/pub?gid=0&single=true&output=csv";

  // Icon files in repo
  const AREA_INDEX_URL = "data/area_centroids_salem.json";
  const ICONS = {
    LoveBox: { name: "lovebox", path: "assets/icons/lovebox-pin.png" },
    "Dare to Dream": { name: "daretodream", path: "assets/icons/daretodream-pin.png" }
  };

  // --- Helpers ---
  async function fetchCSV(url) {
  const txt = await (await fetch(url, { cache: "no-store" })).text();
  const lines = txt.replace(/\r\n?/g, "\n").split("\n").filter(l => l.length > 0);

  function splitLine(line) {
    const cells = [];
    let cur = "", inQ = false;
    for (let i = 0; i < line.length; i++) {
      const ch = line[i];
      if (ch === '"') {
        if (inQ && line[i + 1] === '"') { cur += '"'; i++; }  // escaped quote ("")
        else { inQ = !inQ; }
      } else if (ch === ',' && !inQ) {
        cells.push(cur); cur = "";
      } else {
        cur += ch;
      }
    }
    cells.push(cur);
    return cells;
  }

  const headers = splitLine(lines[0]).map(h => h.trim());
  return lines.slice(1).map(line => {
    const cells = splitLine(line);
    const row = {};
    headers.forEach((h, i) => {
      let v = (cells[i] ?? "");
      // trim *outside* quotes; keep commas inside quoted fields
      v = v.trim();
      if (v.startsWith('"') && v.endsWith('"')) v = v.slice(1, -1);
      v = v.replace(/""/g, '"'); // unescape quotes
      row[h] = v;
    });
    return row;
  });
}


  async function loadAreaIndex() {
    return await (await fetch(AREA_INDEX_URL, { cache: "no-store" })).json();
  }
  // Adds random jitter to each point, new jitter each time. Fancy math stuff. 
  function jitter([lng, lat]) {
    const meters = 1000 + Math.random() * 1000; // 300–600 m
    const theta = Math.random() * 2 * Math.PI;
    const dLat = (meters * Math.cos(theta)) / 111320;
    const dLng = (meters * Math.sin(theta)) / (111320 * Math.cos(lat * Math.PI / 180));
    return [lng + dLng, lat + dLat];
  }

  function rowsToGeoJSON(rows, areaIndex) {
    const features = [];
    for (const r of rows) {
const progRaw = (r.program || "").trim();
const prog = /dare\s*to\s*dream/i.test(progRaw) ? "Dare to Dream" : "LoveBox";
const area = (r.area || "").trim();
      // Prefer explicit lat/lon if provided, otherwise area→centroid+jitter
      let lng = parseFloat(r.lon), lat = parseFloat(r.lat);
      if (!(isFinite(lng) && isFinite(lat))) {
        if (area && areaIndex[area]) {
          [lng, lat] = jitter(areaIndex[area]);
        } else {
          // skip rows that can’t place safely
          continue;
        }
      }
      features.push({
        type: "Feature",
        geometry: { type: "Point", coordinates: [lng, lat] },
        properties: {
          id: r.id || "",
          display_name: r.display_name || "Family",
          program: prog,                           // LoveBox | Dare to Dream
          summary: r.summary || "",
          city: r.city || "",
          area: area || "",
          needs: (r.needs || "").split(";").map(s => s.trim()).filter(Boolean),
          urgency: (r.urgency || "medium").toLowerCase(),
          status: (r.status || "waitlist").toLowerCase(),
          iconKey: ICONS[prog]?.name || ICONS.LoveBox.name // default icon
        }
      });
    }
    return { type: "FeatureCollection", features };
  }

  // --- Map init ---
  const map = new maplibregl.Map({
    container: 'map',
    style: `https://api.maptiler.com/maps/basic/style.json?key=${MAPTILER_KEY}`,
    center: [-123.04, 44.94],
    zoom: 10
  });
  map.addControl(new maplibregl.NavigationControl(), 'top-left');
// Error Logging
  map.on('error', (e) => console.error('Map error:', e && e.error));

  map.on('load', async () => {
    try {
      const [areas, rows] = await Promise.all([loadAreaIndex(), fetchCSV(SHEET_CSV_URL)]);
      const geo = rowsToGeoJSON(rows, areas);

      map.addSource('families', { type: 'geojson', data: geo });

      // Load both icons, then draw
      const loadIcon = (def) => new Promise((resolve, reject) => {
        map.loadImage(def.path, (err, img) => {
          if (err) return reject(err);
          if (!map.hasImage(def.name)) map.addImage(def.name, img);
          resolve();
        });
      });
      await Promise.all(Object.values(ICONS).map(loadIcon));

      // Symbol layer uses icon-image by property
      map.addLayer({
        id: 'families-pins',
        type: 'symbol',
        source: 'families',
        layout: {
          'icon-image': ['get', 'iconKey'], // properties.iconKey matches added images by name
          'icon-size': 0.9,
          'icon-anchor': 'bottom',
          'icon-allow-overlap': true
        }
      });

      // Soft urgency halo
      map.addLayer({
        id: 'families-halo',
        type: 'circle',
        source: 'families',
        paint: {
          'circle-radius': 10,
          'circle-color': [
            'match',
            ['get','urgency'],
            'high', '#E53935',
            'medium', '#FB8C00',
            'low', '#43A047',
            /* default */ '#607D8B'
          ],
          'circle-opacity': 0.15
        }
      });

      // Popup
      map.on('click', 'families-pins', (e) => {
        const f = e.features[0], p = f.properties;
        const html = `
          <div class="popup">
            <h3>${p.display_name}</h3>
            <div>${p.program}${p.area ? ` · ${p.area}` : ""}${p.city ? ` · ${p.city}` : ""}</div>
            ${p.summary ? `<p><strong>Summary:</strong> ${p.summary}</p>` : ""}
            ${(() => {
  let needs = [];
  if (Array.isArray(p.needs)) {
    needs = p.needs;
  } else if (typeof p.needs === "string" && p.needs.trim()) {
    try {
      const parsed = JSON.parse(p.needs);
      needs = Array.isArray(parsed) ? parsed : p.needs.split(";").map(s=>s.trim()).filter(Boolean);
    } catch {
      needs = p.needs.split(";").map(s=>s.trim()).filter(Boolean);
    }
  }
  return needs.length ? `<div style="margin-top:6px"><strong>Needs:</strong> ${needs.join(", ")}</div>` : "";
})()}

          </div>
        `;
        new maplibregl.Popup({ offset: 16 })
          .setLngLat(f.geometry.coordinates)
          .setHTML(html)
          .addTo(map);
      });

      map.on('mouseenter', 'families-pins', () => map.getCanvas().style.cursor = 'pointer');
      map.on('mouseleave', 'families-pins', () => map.getCanvas().style.cursor = '');

    } catch (e) {
      console.error("Load error:", e);
    }
  });
</script>
</body>
</html>

